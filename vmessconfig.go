package vmessconfig

import (
	"context"
	"fmt"
	"github.com/v2fly/v2ray-core/v4/infra/conf"
	"github.com/yindaheng98/vmessconfig/util"
)

type Config interface{}

type BaseConfig struct {
	PingConfig *PingConfig `json:"pingConfig"`
}

type SingleNodeConfig struct {
	BaseConfig
	OutboundInsertBeforeTag string `json:"outboundInsertBeforeTag" desc:"Insert outbound before the exists outbound whose tag is this"`
}

func DefaultSingleNodeConfig() *SingleNodeConfig {
	return &SingleNodeConfig{
		BaseConfig:              BaseConfig{PingConfig: DefaultPingConfig()},
		OutboundInsertBeforeTag: "vmessconfig-outbound-insert",
	}
}

type BalancerConfig struct {
	BaseConfig
	OutboundInsertBeforeTag string `json:"outboundInsertBeforeTag" desc:"Insert outbound before the exists outbound whose tag is this"`
	TagFormat               string `json:"tagFormat" desc:"Format of the auto-generated outbounds' tag"`
	BalancerInsertToTag     string `json:"balancerInsertToTag" desc:"Insert the selector into the balancer whose tag is this"`
	MaxSelect               uint   `json:"maxSelect" desc:"How many outbounds do you want to put into"`
}

func DefaultBalancerConfig() *BalancerConfig {
	return &BalancerConfig{
		BaseConfig:              BaseConfig{PingConfig: DefaultPingConfig()},
		OutboundInsertBeforeTag: "vmessconfig-outbound-insert",
		TagFormat:               "vmessconfig-autogenerated-%d",
		BalancerInsertToTag:     "vmessconfig-autogenerated-balancer",
		MaxSelect:               8,
	}
}

func getSortedVmessList(urls []string, config *PingConfig, ctx context.Context) ([]string, error) {
	vmesslists := make([]string, 0)
	for _, url := range urls {
		vmesslist, err := util.GetVmessList(url)
		if err != nil {
			continue
		}
		vmesslists = append(vmesslists, vmesslist...)
	}
	vmessstats := VmessPingAll(vmesslists, config, ctx)
	vmesslists = util.VmessSort(vmessstats)
	if len(vmesslists) <= 0 {
		return []string{}, fmt.Errorf("no valid vmess")
	}
	return vmesslists, nil
}

func VmessConfigBalancer(urls []string, template *conf.Config, config *BalancerConfig, ctx context.Context) (*conf.Config, error) {
	vmesslist, err := getSortedVmessList(urls, config.PingConfig, ctx)
	if err != nil {
		return nil, err
	}
	max := int(config.MaxSelect)
	if len(vmesslist) < max {
		max = len(vmesslist)
	}
	outboundDetourConfigs := util.VmessListParse(vmesslist[0:max], config.PingConfig.UseMux, config.PingConfig.AllowInsecure)
	template = util.VmessBalancerConfigMerge(outboundDetourConfigs, template, config.TagFormat, config.OutboundInsertBeforeTag, config.BalancerInsertToTag)
	return template, nil
}

func VmessConfigSingleNode(urls []string, template *conf.Config, config *SingleNodeConfig, ctx context.Context) (*conf.Config, error) {
	vmesslist, err := getSortedVmessList(urls, config.PingConfig, ctx)
	if err != nil {
		return nil, err
	}
	outboundDetourConfig, err := util.VmessParse(vmesslist[0], config.PingConfig.UseMux, config.PingConfig.AllowInsecure)
	if err != nil {
		return nil, err
	}
	template = util.VmessSingleNodeConfigMerge(outboundDetourConfig, template, config.OutboundInsertBeforeTag)
	return template, nil
}

func VmessConfig(urls []string, template *conf.Config, config Config, ctx context.Context) (*conf.Config, error) {
	var c interface{} = config
	switch inst := c.(type) {
	case *BalancerConfig:
		return VmessConfigBalancer(urls, template, inst, ctx)
	case *SingleNodeConfig:
		return VmessConfigSingleNode(urls, template, inst, ctx)
	default:
		return nil, fmt.Errorf("INVALID CONFIG TYPE: %+v", inst)
	}
}
