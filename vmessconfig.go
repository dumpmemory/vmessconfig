package vmessconfig

import (
	"context"
	"fmt"
	"github.com/yindaheng98/vmessconfig/util"
)

type Config interface{}

type BaseConfig struct {
	PingConfig  *PingConfig `json:"pingConfig"`
	TagFormat   string      `json:"tagFormat" desc:"Format of the auto-generated outbounds' tag. If it is 'fixed', tagKeyFieldName will be the tag"`
	TagKeyField string      `json:"tagKeyField" desc:"Field in vmess link used as key of the auto-generated outbounds' tag. If it is 'number', tag key will be its order number in the config list (from 0)"`
}

func DefaultBaseConfig() BaseConfig {
	return BaseConfig{
		PingConfig:  DefaultPingConfig(),
		TagFormat:   "vmessconfig-%s",
		TagKeyField: "Ps",
	}
}

type SingleNodeConfig struct {
	BaseConfig
	OutboundInsertBeforeTag string `json:"outboundInsertBeforeTag" desc:"Insert outbound before the exists outbound whose tag is this"`
}

func DefaultSingleNodeConfig() *SingleNodeConfig {
	s := &SingleNodeConfig{
		BaseConfig:              DefaultBaseConfig(),
		OutboundInsertBeforeTag: "vmessconfig-outbound-insert",
	}
	s.TagFormat = "fixed"
	s.TagKeyField = "vmessconfig-autogenerated-proxy"
	return s
}

type BalancerConfig struct {
	BaseConfig
	OutboundInsertBeforeTag string `json:"outboundInsertBeforeTag" desc:"Insert outbound before the exists outbound whose tag is this"`
	BalancerInsertToTag     string `json:"balancerInsertToTag" desc:"Insert the selector into the balancer whose tag is this"`
	MaxSelect               uint   `json:"maxSelect" desc:"How many outbounds do you want to put into"`
}

func DefaultBalancerConfig() *BalancerConfig {
	return &BalancerConfig{
		BaseConfig:              DefaultBaseConfig(),
		OutboundInsertBeforeTag: "vmessconfig-outbound-insert",
		BalancerInsertToTag:     "vmessconfig-autogenerated-balancer",
		MaxSelect:               8,
	}
}

func getSortedVmessList(urls []string, config *PingConfig, ctx context.Context) ([]string, error) {
	vmesslists := make([]string, 0)
	for _, url := range urls {
		vmesslist, err := util.GetVmessList(url)
		if err != nil {
			continue
		}
		vmesslists = append(vmesslists, vmesslist...)
	}
	vmessstats := VmessPingAll(vmesslists, config, ctx)
	vmesslists = util.VmessSort(vmessstats)
	if len(vmesslists) <= 0 {
		return []string{}, fmt.Errorf("no valid vmess")
	}
	return vmesslists, nil
}

func VmessConfigBalancer(urls []string, template V2Config, config *BalancerConfig, ctx context.Context) (V2Config, error) {
	vmesslist, err := getSortedVmessList(urls, config.PingConfig, ctx)
	if err != nil {
		return nil, err
	}
	max := int(config.MaxSelect)
	if len(vmesslist) < max {
		max = len(vmesslist)
	}
	outboundDetourConfigs := util.VmessListParse(
		vmesslist[0:max],
		config.TagFormat, config.TagKeyField,
		config.PingConfig.UseMux, config.PingConfig.AllowInsecure,
	)
	template = VmessBalancerConfigMerge(outboundDetourConfigs, template, config.OutboundInsertBeforeTag, config.BalancerInsertToTag)
	return template, nil
}

func VmessConfigSingleNode(urls []string, template V2Config, config *SingleNodeConfig, ctx context.Context) (V2Config, error) {
	vmesslist, err := getSortedVmessList(urls, config.PingConfig, ctx)
	if err != nil {
		return nil, err
	}
	outboundDetourConfig, err := util.VmessParse(
		vmesslist[0],
		config.TagFormat, config.TagKeyField,
		config.PingConfig.UseMux, config.PingConfig.AllowInsecure,
	)
	if err != nil {
		return nil, err
	}
	template = VmessSingleNodeConfigMerge(outboundDetourConfig, template, config.OutboundInsertBeforeTag)
	return template, nil
}

func VmessConfig(urls []string, template V2Config, config Config, ctx context.Context) (V2Config, error) {
	var c interface{} = config
	switch inst := c.(type) {
	case *BalancerConfig:
		return VmessConfigBalancer(urls, template, inst, ctx)
	case *SingleNodeConfig:
		return VmessConfigSingleNode(urls, template, inst, ctx)
	default:
		return nil, fmt.Errorf("INVALID CONFIG TYPE: %+v", inst)
	}
}
